import matplotlib.pyplot as plt
import math
import ot
from tqdm import tqdm
import torch
import numpy as np
from scipy.stats import t as t_scipy

from datacreation import euclidean_cost_matrix

SMALL = 8
MEDIUM = 12
BIG = 16

plt.rc('font', size=MEDIUM)         # controls default text sizes
plt.rc('axes', titlesize=BIG)       # fontsize of the axes title
plt.rc('axes', labelsize=MEDIUM)    # fontsize of the x and y labels
plt.rc('xtick', labelsize=MEDIUM)   # fontsize of the tick labels
plt.rc('ytick', labelsize=MEDIUM)   # fontsize of the tick labels
plt.rc('legend', fontsize=MEDIUM)   # legend fontsize
plt.rc('figure', titlesize=BIG)     # fontsize of the figure title


def visualize_data(data):
    """
    Visualizes data as black and white images.
    :param data: iterable containing samples generated by 'generate_simple_data'.
    """
    length = int(math.sqrt(len(data[0]['d1'][0])))
    fig, axes = plt.subplots(len(data), 2, figsize=(20,20))
    for i,ax in enumerate(axes.flat):
        if i%2 == 0:
            ax.imshow(data[i//2]['d1'].reshape(length, length), cmap='Greys')
        else:
            ax.imshow(data[i//2]['d2'].reshape(length, length), cmap='Greys')
    fig.show()

def visualize_data2(data, row = None, column = None):
    """
    Visualizes data as black and white images.
    :param data: list or array of size [n,dim] or [n, l, l], where n is the number of images to be visualized, and dim is the number of pixels per image (l is the height/width).
    :param row: optional parameter determining the number of rows.
    :param column: optimal parameter determining the number of columns.
    """
    if len(data.size()) == 2:
        length = int(math.sqrt(data.size(1)))
        data = data.reshape(data.size(0), length, length)
    if not row:
        fig, axes = plt.subplots(len(data), figsize=(8,8))

    else:
        fig, axes = plt.subplots(row, column, figsize=(8,8))
    if not row:
        for i,ax in enumerate(axes):
            ax.imshow(data[i], cmap='Greys')
    else:
        for j in range(row):
            for i,ax in enumerate(axes[j]):
                ax.imshow(data[j*column+i], cmap='Greys')
    fig.show()

def check_accuracy(batch, method, reg, costmatrix = None):
    """
    Checks the accuracy of a `method`-Sinkhorn solver from the POT package compared to a batch of data.
    :param method: method of the Sinkhorn solver.
    :param reg: regularizer of the Sinkhorn solver.
    :param costmatrix: cost matrix to be used for OT computations. If 'None', defaults to squared Euclidean distance.
    """
    if costmatrix == None:
        length = int(math.sqrt(batch['d1'].size()[1]))
        costmatrix = euclidean_cost_matrix(length, length, 2, True)
    n_sample = batch['d1'].size()[0]
    err = 0
    for i in tqdm(range(n_sample)):
        ws_sinkhorn = ot.sinkhorn2(batch['d1'][i], batch['d2'][i], costmatrix, reg, method=method)
        err += abs(ws_sinkhorn - batch['cost'][i]).item()
    err /= n_sample
    return err

def compute_c_transform(cost, sample):
    """
    Computes the c transform of 'sample' w.r.t. to cost matrix 'cost'. Both inputs are required to be of dimension 2. Supports multiple samples.
    """
    lamext=sample.reshape(len(sample),len(sample[0]),1).expand(len(sample),len(sample[0]),len(sample[0])).transpose(2,1)
    lamstar=(cost-lamext).amin(dim=2).float()
    del lamext
    torch.cuda.empty_cache()
    return lamstar

def compute_dual(alpha, beta, u, v):
    """
    Computes the dual value of the OT problem as `\int u \, d\alpha + \int v \, d\beta`. All inputs are required to be of dimension 2. Supports multiple samples in 'u' and 'v'.
    Either u or v can be None, in which case it is replaced by the c-transform of the other.
    """
    if u == None:
        l = int(math.sqrt(v.size(1)))
        c = euclidean_cost_matrix(l, l, 2, True)
        u = compute_c_transform(c, v)
    elif v == None:
        l = int(math.sqrt(v.size(1)))
        c = euclidean_cost_matrix(l, l, 2, True)
        v = compute_c_transform(c, u)
    values = torch.sum(alpha*u, dim=1) + torch.sum(beta*v, dim=1)
    return values[None, :].T

def compute_mean_conf(data, conf):
    """
    Given a list of lists of datapoints, computes their mean values and a confidence interval.
    :param data: list of lists or list-like objects.
    :param conf: desired confidence between 0 and 1.
    """
    n = len(data)
    for i in range(n):
        data[i] = np.array(data[i])
    x     = np.array(data)
    means = x.mean(0)
    stds  = x.std(0)
    dof   = len(x) - 1
    t     = np.abs(t_scipy.ppf((1 - conf)/2, dof))
    lowers = means - stds * t/np.sqrt(len(x))
    uppers = means + stds * t/np.sqrt(len(x))
    return(lowers, means, uppers)


def plot(
            y,
            x = None,
            labels = None,
            x_label = '',
            y_label = ''
        ):
    """
    Plots data.
    y: List of lists, each containing data of one type. All lists in y have to be of the same length.
    x: List of lists. Values for x-axis. If `None`, defaults to [0, 1, 2, ..., len(y[0])] for each list in y.
    labels: List of labels for each list in y.
    """
    if x == None:
        x = [[i for i in range(len(y[0]))]]
    if len(x) == 1:
        x = [x[0] for i in range(len(y))]
    if labels == None:
        labels = ['Abs. error on WS distance', 'Rel. error on WS distance', 'L2 error on potential']
    for i in range(len(y)):
        plt.plot(x[i], y[i], label=labels[i])
    plt.xlabel(x_label)
    plt.ylabel(y_label)
    plt.legend()
    plt.show()


def plot_conf(
                x,
                y,
                labels,
                x_label,
                y_label,
                titles = None,
                separate_plots = None,
                rows = None,
                columns = None
            ):
    """
    Plots data containing average values alongside their confidence intervals as shaded areas.
    :param x: list containing x values. Can also be an integer, in which case it is converted to a list of numbers interpolating between 0 and that integer.
    :param y: list of lists. Each contains three lists, the first corresponding to the lower confidence bound, the second to the average, the third to the upper confidence bound.
    :param labels: list of same length as `y` containing the labels for each plot.
    :param x_label: label for x axis.
    :param y_label: label for y axis.
    :param titles: optional titles for each plot.
    :param separate_plots: optional parameter to split data into separate plots. If given, this should be a list of tuples, each tuple containing the data indices for a plot.
    :param rows: number of rows for subplots. If None, all subplots will be in one row.
    :param columns: number of columns for subplots.
    """
    if isinstance(x, int):
        x = [i*x/(len(y[0][0])-1) for i in range(len(y[0][0]))]
    n = len(y)
    if not separate_plots:
        colors = iter(plt.cm.rainbow(np.linspace(0, 1, n)))
        for i in range(n):
            color = next(colors)
            plt.fill_between(x, y[i][0], y[i][2], color=color/3, linewidth=0)
            plt.plot(x, y[i][1], label=labels[i], color=color)
        plt.ylim(bottom=0)
        plt.xlabel(x_label)
        plt.ylabel(y_label)
        if titles:
            plt.title(titles)
        plt.legend()
        plt.show()
    else:
        nb_plots = len(separate_plots)
        if rows == None:
            rows = 1
            columns = nb_plots
        fig, axes = plt.subplots(rows, columns, sharex='col', figsize=(8,8))
        if rows == 1:
            axes = [axes]
        if columns == 1:
            axes = [[ax] for ax in axes]
        if titles:
            titles = iter(titles)
        for r in range(rows):
            for i, ax in enumerate(axes[r]):
                colors = iter(plt.cm.rainbow(np.linspace(0, 1, len(separate_plots[r*columns+i]))))
                for j in separate_plots[r*columns+i]:
                    color = next(colors)
                    ax.fill_between(x, y[j][0], y[j][2], color=color/3, linewidth=0)
                    ax.plot(x, y[j][1], label=labels[j], color=color)
                ax.set_ylim(bottom=0)
                if r == rows-1:
                    ax.set_xlabel(x_label)
                if i == 0:
                    ax.set_ylabel(y_label)
                if titles:
                    ax.set_title(next(titles))
                ax.legend()
        fig.show()

if __name__ == '__main__':
    from Results.results1 import *
    xl = 'training samples'
    yl = 'L2 error on potential'
    x = 100000
